\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{hyperref}

\title{Piecewise Polynomial Path Planner ($P^4$)}
\author{Tucker Haydon}
\date{Spring 2019}

\begin{document}

\maketitle

\section{Introduction}
This package is a C++ implementation of a piecewise-polynomial path-planner.

\section{Polynomial Theory}
\subsection{Problem Statement}
Given a set of $m$, $k$-dimensional waypoints 
%
\begin{equation}
  \mathbf{W} = 
  \begin{bmatrix}
    \vec{w}_{0} & \vec{w}_{1} & \vec{w}_{2} & \hdots & \vec{w}_{m}
  \end{bmatrix}
\end{equation}
%
and a set of times to arrive at these waypoints 
\begin{equation}
  \vec{T} = 
  \begin{bmatrix}
    t_{0} & t_{1} & t_{2} & \hdots & t_{m}
  \end{bmatrix}
\end{equation}
%
construct a set of $N$th-order piecewise polynomials that smoothly connect these waypoints
%
\begin{equation}
  \vec{p}(t) = 
  \begin{cases}
    \sum_{n=0}^{N} p_{0,n} \cdot (\frac{1}{n!} t^{n}) & t_{0} \leq t < t_{1} \\ 
    \sum_{n=0}^{N} p_{1,n} \cdot (\frac{1}{n!} t^{n}) & t_{1} \leq t < t_{2} \\ 
    \vdots \\
    \sum_{n=0}^{N} p_{m,n} \cdot (\frac{1}{n!} t^{n}) & t_{m-1} \leq t < t_{m}
  \end{cases}
\end{equation}
%
while minimizing the squared norm of the $r$th derivative
%
\begin{equation}
  \min
  \int_{t_{0}}^{t_{m}} \frac{d^{r}}{dt^{r}}|| \vec{p}(t) ||^{2} dt
\end{equation}
%
This problem construction and the following solution follow those of Mellinger
and Kumar \cite{mellinger2011minimum}.

\subsection{Quadratic Programming}
The problem of finding these piecewise polynomials can be cast as a quadratic
programming problem:
%
\begin{equation}
  \begin{split}
    \min_{\vec{x}} \quad& \frac{1}{2} \vec{x}^T \mathbf{P} \vec{x}  \\
    \text{s.t.} \quad& \vec{l} \leq \mathbf{A} \vec{x} \leq \vec{u}
  \end{split}
\end{equation}
%
\href{https://osqp.org}{OSQP} is used to solve the QP problem \cite{osqp}.

\section{Scaling}
Waypoint arrival times are arbitrary --- they can be as small as a millisecond
or as large as a minute. In order to avoid numerical instability in the QP
solver due to exponentiation of potentially large and small times, segment
duration is normalized to unity. This normalized time is refered to as the
`computation time'.

Let $t \in [0, t_{f}]$ represent the physical time along a segment and $\tau \in
[0, 1]$ represent the computational time along a segment. The two are related by
a scaling factor.
%
\begin{equation}
  t = \alpha \tau
\end{equation}
%
Path constraints are specified using physical time. These must be converted to
constraints in computational time. Define a constraint:
%
\begin{equation}
  \frac{dP(t/\alpha)}{dt} < \kappa
\end{equation}
%
Change of basis using $\tau = t / \alpha$ and $d\tau = dt / \alpha$. Substitute
and rearrange:
%
\begin{equation}
  \frac{dP(\tau)}{d\tau} < \alpha \kappa
\end{equation}
%
Constraints on higher derivatives are derived using the same process.
\begin{equation}
  \frac{dP^{n}(t/\alpha)}{dt^{n}} < \kappa \rightarrow
  \frac{dP^{n}(\tau)}{d\tau^{n}} < \alpha^{n} \kappa
\end{equation}
%
Continuity constraints merit special consideration. These constraints require
that the $n$th derivative of the end of a segment match the $n$th derivative of
the following segment. Since the time scaling of each segment may be different,
the constraint manifests so:
\begin{equation}
  \frac{dP_{k}^{n}(\tau)}{d\tau^{n}} \frac{1}{\alpha_{k}^{n}} =
  \frac{dP_{k+1}^{n}(\tau)}{d\tau^{n}} \frac{1}{\alpha_{k+1}^{n}}
\end{equation}

\section{Usage Notes}
\begin{enumerate}
  \item The polynomial order must be greater than 1.
  \item The position, velocity, and acceleration for the initial node must all
    be specified. 
\end{enumerate}

\bibliography{main}
\bibliographystyle{IEEEtran}

\end{document}
